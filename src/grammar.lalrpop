use crate::lexer;
use crate::ast;

use std::str::FromStr;

grammar<'input>;

extern {
    type Location = usize;
    type Error = lexer::Error;

    enum lexer::Token<'input> {
        string => lexer::Token::StringLiteral(<&'input str>),
        int => lexer::Token::IntLiteral(<&'input str>),
        ident => lexer::Token::Ident(<&'input str>),
        // "\n" => lexer::Token::Newline,

        "const" => lexer::Token::Const,
        "var" => lexer::Token::Var,
        "->" => lexer::Token::Arrow,
        "func" => lexer::Token::Func,
        "extern" => lexer::Token::Extern,

        "&" => lexer::Token::Ampersand,
        "," => lexer::Token::Comma,

        "if" => lexer::Token::If,
        "true" => lexer::Token::True,
        "false" => lexer::Token::False,
        "and" => lexer::Token::And,
        "or" => lexer::Token::Or,
        "not" => lexer::Token::Not,
        "while" => lexer::Token::While,

        "(" => lexer::Token::LParen,
        ")" => lexer::Token::RParen,
        "{" => lexer::Token::LCurly,
        "}" => lexer::Token::RCurly,
        "[" => lexer::Token::LSquare,
        "]" => lexer::Token::RSquare,
        ":" => lexer::Token::Colon,
        ";" => lexer::Token::Semicolon,
        "=" => lexer::Token::Equals,

        // Math
        "+" => lexer::Token::Plus,
        "-" => lexer::Token::Minus,
        "*" => lexer::Token::Times,
        "/" => lexer::Token::Divide,
        "%" => lexer::Token::Percent,

        // Types
        "int" => lexer::Token::Int,
        "int8" => lexer::Token::Int8,
        "int16" => lexer::Token::Int16,
        "int32" => lexer::Token::Int32,
        "int64" => lexer::Token::Int64,
        "uint" => lexer::Token::UInt,
        "uint8" => lexer::Token::UInt8,
        "uint16" => lexer::Token::UInt16,
        "uint32" => lexer::Token::UInt32,
        "uint64" => lexer::Token::UInt64,
        "char" => lexer::Token::Char,
        "str" => lexer::Token::Str,
    }
}

pub Program: ast::Program = <TopLevelStmt*> => ast::Program(<>);

TopLevelStmt: ast::TopLevelStmt = {
    <FunctionDef> => ast::TopLevelStmt::FunctionDef(<>),
    <ConstDef> => ast::TopLevelStmt::ConstDef(<>),
    <ExternDef> => ast::TopLevelStmt::ExternDef(<>),
}

pub FunctionDef: ast::FunctionDef = "func" <name:Ident> "(" <params:MaybeParamsList> ")" <return_type:("->" <Type>)?> <body:BlockStmt> => ast::FunctionDef {<>};

ExternDef: ast::ExternDef = "extern" <name:Ident> "(" <params:MaybeParamsList> ")" <return_type:("->" <Type>)?> ";" => ast::ExternDef {<>};

MaybeParamsList: Vec<ast::TypeBinding> = <ParamsList?> => <>.unwrap_or(vec![]);

ParamsList: Vec<ast::TypeBinding> = {
    <mut a:ParamsList> ","  <b:TypeBinding> => {a.push(b); a},
    <TypeBinding> => vec![<>],
}

// STATEMENTS

pub Stmt: ast::Stmt = {
    <Expr> ";" => ast::Stmt::ExprStmt(<>),
    <BlockStmt> => ast::Stmt::BlockStmt(<>),
    <IfStmt>,
    <WhileStmt>,
    <ConstDef> => ast::Stmt::ConstDef(<>),
    <VarDef> => ast::Stmt::VarDef(<>),
}

BlockStmt: ast::BlockStmt =
    "{" <Stmt*> "}" => ast::BlockStmt(<>);

IfStmt: ast::Stmt =
    "if" "(" <condition:Expr> ")" <body:BlockStmt> => ast::Stmt::IfStmt(ast::IfStmt {<>});

WhileStmt: ast::Stmt =
    "while" "(" <condition:Expr> ")" <body:BlockStmt> => ast::Stmt::WhileStmt(ast::WhileStmt {<>});

ConstDef: ast::ConstDef =
    "const" <binding:TypeBinding> "=" <value:Expr> ";" => ast::ConstDef{ <> };

VarDef: ast::VarDef =
    "var" <binding:TypeBinding> "=" <value:Expr> ";" => ast::VarDef { <> };


// EXPRESSIONS

TypeBinding: ast::TypeBinding =
    <n:Ident> ":" <t:Type> => ast::TypeBinding { name: n, value_type: t};

Type: ast::Type = {
    "[" <Type> "]" => ast::Type::Array(Box::new(<>)),
    "int" => ast::Type::Int,
    "int8" => ast::Type::Int8,
    "int16" => ast::Type::Int16,
    "int32" => ast::Type::Int32,
    "int64" => ast::Type::Int64,
    "uint" => ast::Type::UInt,
    "uint8" => ast::Type::UInt8,
    "uint16" => ast::Type::UInt16,
    "uint32" => ast::Type::UInt32,
    "uint64" => ast::Type::UInt64,
    "char" => ast::Type::Char,
    "str" => ast::Type::Str,
}

pub Expr: ast::Expr = {
    <AndExpr>,
}

AndExpr: ast::Expr = {
    <l:AndExpr> "and" <r:OrExpr> => ast::Expr::Binary(Box::new(l), ast::BinOp::LogicalAnd, Box::new(r)),
    <OrExpr>,
}

OrExpr: ast::Expr = {
    <l:OrExpr> "or" <r:ArithmaticExpr> => ast::Expr::Binary(Box::new(l), ast::BinOp::LogicalOr, Box::new(r)),
    <ArithmaticExpr>,
}

ArithmaticExpr: ast::Expr = {
    <l:ArithmaticExpr> <op:AddOp> <r:Term> => ast::Expr::Binary(Box::new(l), op, Box::new(r)),
    <Term>,
}

Term: ast::Expr = {
    <l:Term> <op:MulOp> <r:PrimaryExpr> => ast::Expr::Binary(Box::new(l), op, Box::new(r)),
    <UnaryExpr>,
}

// Unary expressions:
UnaryExpr: ast::Expr = {
    <op:UnaryOp> <value:FunctionCall> => ast::Expr::Unary(op, Box::new(value)),
    <FunctionCall>,
}

// TODO: name could just be an identifier
FunctionCall: ast::Expr = {
    <name:FunctionCall> "(" <params:MaybeArgsList> ")" => ast::Expr::FunctionCall(ast::FunctionCall { name: Box::new(name), params: params}),
    <PrimaryExpr>,
}

MaybeArgsList: Vec<ast::Expr> = <ArgsList?> => <>.unwrap_or(vec![]);

ArgsList: Vec<ast::Expr> = {
    <mut a:ArgsList> ","  <b:Expr> => {a.push(b); a},
    <Expr> => vec![<>],
}

PrimaryExpr: ast::Expr = {
    <Ident> => ast::Expr::Ident(<>),
    <Literal> => ast::Expr::Literal(<>),
    "true" => ast::Expr::Literal(ast::Literal::True),
    "false" => ast::Expr::Literal(ast::Literal::False),
    "(" <Expr> ")",
}

AddOp: ast::BinOp = {
    "+" => ast::BinOp::Plus,
    "-" => ast::BinOp::Minus,
}

MulOp: ast::BinOp = {
    "*" => ast::BinOp::Times,
    "/" => ast::BinOp::Divide,
}

UnaryOp: ast::UnaryOp = {
    "&" => ast::UnaryOp::Reference,
    "-" => ast::UnaryOp::Minus,
    "not" => ast::UnaryOp::Not,
}

Literal: ast::Literal = {
    <IntLiteral>,
    <StringLiteral>,
}

IntLiteral: ast::Literal =
    <int> => ast::Literal::Int32(i32::from_str(<>).unwrap());

StringLiteral: ast::Literal =
    <string> => ast::Literal::Str(<>.to_owned());

Ident: ast::Ident = <ident> => ast::Ident(<>.to_owned());