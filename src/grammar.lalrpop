use crate::lexer;
use crate::ast;

use std::str::FromStr;

grammar<'input>;

extern {
    type Location = usize;
    type Error = lexer::Error;

    enum lexer::Token<'input> {
        string => lexer::Token::StringLiteral(<&'input str>),
        int => lexer::Token::IntLiteral(<&'input str>),
        ident => lexer::Token::Ident(<&'input str>),
        newline => lexer::Token::Newline,

        "const" => lexer::Token::Const,
        "var" => lexer::Token::Var,

        "(" => lexer::Token::LParen,
        ")" => lexer::Token::RParen,
        ":" => lexer::Token::Colon,
        ";" => lexer::Token::Semicolon,
        "=" => lexer::Token::Equals,

        // Math
        "+" => lexer::Token::Plus,
        "-" => lexer::Token::Minus,
        "*" => lexer::Token::Times,
        "/" => lexer::Token::Divide,

        // Types
        "int" => lexer::Token::Int,
        "int8" => lexer::Token::Int8,
        "int16" => lexer::Token::Int16,
        "int32" => lexer::Token::Int32,
        "int64" => lexer::Token::Int64,
        "uint" => lexer::Token::UInt,
        "uint8" => lexer::Token::UInt8,
        "uint16" => lexer::Token::UInt16,
        "uint32" => lexer::Token::UInt32,
        "uint64" => lexer::Token::UInt64,
    }
}

ConstDef: ast::ConstDef =
    "const" <binding:TypeBinding> "=" <value:Expr> => ast::ConstDef{ <> };

VarDef: ast::VarDef =
    "var" <binding:TypeBinding> "=" <value:Expr> => ast::VarDef { <> };

TypeBinding: ast::TypeBinding =
    <n:Ident> ":" <t:Type> => ast::TypeBinding { name: n, value_type: t};

Type: ast::Type = {
    "int" => ast::Type::Int,
    "int8" => ast::Type::Int8,
    "int16" => ast::Type::Int16,
    "int32" => ast::Type::Int32,
    "int64" => ast::Type::Int64,
    "uint" => ast::Type::UInt,
    "uint8" => ast::Type::UInt8,
    "uint16" => ast::Type::UInt16,
    "uint32" => ast::Type::UInt32,
    "uint64" => ast::Type::UInt64,
}

pub Expr: ast::Expr = {
    <ArithmaticExpr>,
}

ArithmaticExpr: ast::Expr = {
    <l:ArithmaticExpr> <op:AddOp> <r:Term> => ast::Expr::Binary(Box::new(l), op, Box::new(r)),
    Term,
}

Term: ast::Expr = {
    <l:Term> <op:MulOp> <r:PrimaryExpr> => ast::Expr::Binary(Box::new(l), op, Box::new(r)),
    PrimaryExpr,
}

PrimaryExpr: ast::Expr = {
    <Ident> => ast::Expr::Ident(<>),
    <Literal> => ast::Expr::Literal(<>),
}

AddOp: ast::BinOp = {
    "+" => ast::BinOp::Plus,
    "-" => ast::BinOp::Minus,
}

MulOp: ast::BinOp = {
    "*" => ast::BinOp::Times,
    "/" => ast::BinOp::Divide,
}

Literal: ast::Literal = {
    <IntLiteral>,
    <StringLiteral>,
}

IntLiteral: ast::Literal =
    <int> => ast::Literal::Int32(i32::from_str(<>).unwrap());

StringLiteral: ast::Literal =
    <string> => ast::Literal::Str(<>.to_owned());

Ident: ast::Ident = <ident> => ast::Ident(<>.to_owned());